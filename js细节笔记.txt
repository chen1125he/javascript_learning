2.	Javascript区分大小写
3.	Js中未用var定义的变量会成为全局变量即使在一个方法中用到的未用var定义变量在后面的方法里面都能使用
4.	Typeof()的值有undefined/Boolean/string/number/object(是个对象或者null)/function
声明了未赋值就是undefined(一定要先声明，未声明就是报错)
5.	任何类型都有和boolean相匹配的值，数字false是0和NaN，string的false是空串object的false是null
6.	Number类型可以有8进制和16进制(0/0x)
7.	NaN是一个特殊的数值任何涉及NaN的操作都会返回NaN  另NaN不等于NaN
8.	数字转换成字符串的可以和三个Number,parseInt(), parseFloat
Number() Boolean => 0/1, null => 0, undefined => NaN 没有八进制，十六进制会直接转换成同值的十进制
parseInt 有八进制从前向后读取，还可以带两个参数parseInt(‘AF’, 16)指定进制，这时候前面可以不带进制标志
9.	在调用数值型的toString()方法可以在括号里面加个参数，参数是进制
Undefined和null是没有toString()方法的，可以用String(undefined)和String(null)去转换
10.parents和closest相似都是找父级元素，前者返回集合，后者返回单个元素

11.如果数值计算的结果超过了ECMAScript的表示范围，那么结果是Infinity或者是-Infinity(与0相乘是NaN),正Infinity相加是Infinity，负则负，正负相加则是NaN，减法相当于+负的 Infinity

12.字符串的大小比较是比较编码数值，字符串与数值的比较会先转换字符串到数字

13.全等于和不全等于
	5 == "5" // true
	5 === "5" // false 数据类型不等
	5 !== "5" // true

14.逗号操作符
	执行多个操作，并返回最后一个操作的值
	也可以用于声明多个变量
	
15.for-in
	for(property in expression){}
	迭代，可以枚举一个对象里面所有的值,这个值是属性名或者是数组的索引
	var arr = [1, 2, 3, 4, 5, 7, 8];
		Array.prototype.name = "ccyy";
		for(var a in arr){
			console.log(a, arr[a]);
		}//会多输入一个name属性来，但name却并不是arr的属性，这里可以用arr.hasOwnProperty()

16.with，将代码的作用域设置到一个特定的对象中，简化多次编写同一个对象的工作,严格模式下不允许使用，这个好像没多大用
	var qs = location.search.substring(1)
	var hn = location.hostname
	var url = location.href
	=>
	with(location){
		var qs = search.substring(1)
		...
	}
	
17.js的函数不在乎被传递多少参数，传递或者不传递参数，甚至不按定义那样传递参数，即使没有定义参数，也可以传递参数进去
	函数内部有一个arguments，与数组类似，可以用arguments[num]来访问参数，因而它的特点是，参数的命名只是提供便利，但不是必需的
	
18.引用类型变量是object，把一个引用类型变量赋值给另一个变量，他们两个就都指向同一个对象了，不过它们俩各自都是有着自身变量的空间
	小陷阱
	function setName(obj){
		obj.name = "Nicolas";
		obj = new Object();
		obj.name = "Greg";
	}
	var person = new Object();
	setName(person);
	person.name // 依然是"Nicolas"
	
19.作用域链
	局部变量想作用到其他域，可以用1.with, 2.try-catch
	
	js的作用域和c不太相同在for循环和if里面定义的变量还是可以作用到其他地方的, while,do-while也是可以的, switch-case里面也是可以的
	function func(num1, num2){
		sum = num1 + num2; // 如果这个sum没有加var去初始化，那么是可以在外部被访问到的，加了则不行，不过如果在stric模式下会报错
		return sum
	}
	
20.新建一个引用类型变量
	var person = {"name" : "Nicolas", 5 : true, c : 'name'}
	var person = new Object();
	
	访问属性可以用person.name，也可以用person['name'],如果属性名中间带了空格 "na me"就不能用.访问了
	如果是数字，可以用person[5]也可以用person['5'],  像里面的c会自动转化成字符串只能person.c或者person['c'], 不能person[c]
	
21.对于数组来说，arr.length不是只读的可以手动修改的，可以用来一移除后面的值，也可以用来增加数组空间
	arr[arr.length] = value 可以直接在数组末尾添加一个值
	
22.函数也算是对象，可以赋值给另外一个变量
	function fun_a(num){
		return num + 1
	}
	function fun_a(num){
		return num + 2
	}
	这里是想做重载，但实际上会是将fun_a再一次赋值另一个函数
	
23.var fun = function(){}
	function fun(){}
	这两个是不一样的
	第二种对顺序没有要求，不论写在哪都可以，因为一开始会有一个名为函数声明提升的过程，将函数声明添加到执行环境中
	第一个只相当一个变量，运行到这的时候函数才会存在
	这两种的写法区别只在这，什么时候可以调用函数
	也可以这样写，var sum = function sum(){}	//safari会不支持
	但这种也不能在之前就调用这个函数
	sum是这个函数，sum()是这个函数值
	
	函数也是对象，可以拥有方法
	
24.Boolean类型
	bool对象和bool类型是两种概念
	var falseObject = new Boolean(false)
	falseObject && true => true //bool对象在表达式中代码的永远是true
	false instanceof Boolean => false
	falseObject instanceof Boolean => true
	typeof(falseObject) => object 	//是对象
	typeof(false) => boolean	//是boolean类型
25.同Boolean类型一样，Number类型也重写了valueOf(), toLocalString()和toString()
	number.toString()可以传递
	number.toFixed(),可以转换成保留传入参数的小数位数的字符串，会四舍五入
	
26.String
	str.length,返回字符串长度
	str.charAt(position)// 也可以用str[postion]
	str.charCodeAt(postion)//返回编码
	String.fromCharCode(intCode1[, intCode2])//返回字符串，String的静态方法
	str.concat(str1, str2)//会返回拼接的字符串，原串不变
	str.substr(startPosition[, length])//字符串截取，如果长度是负，那会转成0,开始位置是负数的话，length+(负数)
	str.substring(startPosition[, endPosition])//字符串截取，可以输入负数，但会转换成0，会比较开始和结束位置，自动把大的那个数作为开始位置
	str.slice(startPosition[, endPosition])//负数会的方法是length+(负数)
	
	str.indexOf(str[, startPosition])
	str.lastIndexOf(str[, startPosition])
	
	可以通过改变position的值，循环出一个字符串中被查找的字符串所有的位置
	var positions = [];
	var pos = stringValue.indexOf("e");
	while(pos > -1){
		position.push(pos);
		pos = stringValue.indexOf("e", pos+1)
	}
	
	str.trim()	//删除前后前格
	
	str.toLowerCase()//大小写转换
	str.toUpperCase()
	
	str.match(pattern)和exec相似，返回的是第一次匹配到的串，数组里面的是分组，
	str.search(pattern),查找位置
	str.replace(/sd/g, "")//带了g可以替换全局, 可以用$num引用分组($0好像没用？chorm)，$$才是美元符号， $'匹配到子串之前的字符串， $`匹配到子串之后的字符串， $&整个匹配到的子字符串
		str.replace(pattern, function(matchedString, position, originalText){})
	str.split(string/pattern),若分隔符号出现在最左或者最右，那么也会多出一个空串
	str.localeCompare(str2)//比的是谁在谁后面
27.Global对象
	encodeURI()/decodeURI() //处理空格
	encodeURIComponent()/decodeURICompontent()//处理非数字字母字符
	
	eval() //是个解析器，可以把js的表达式的字符串运行
	
	Math.PI	//
	Math.max/min()	//不是传数组
	Math.ceil()		//向上舍入
	Math.floor()	//向下舍入
	Math.round()	//四舍五入
	
	Math.random() * max => (0, max); 
		Math.floor(Math.random() * 可能值的总数 + 第一个可能的值) 比如1-100 Math.random() * 100 => (0, 100) + 1 => (1, 101)再向下舍
	
	Math.abs(num) //绝对值
	Math.exp(num) //返回Math.E的num次幂
	Math.log(num) //返回num的自然对数
	Math.pow(num, power) //返回num的power的次幂
	Math.sqrt(num) //返回num的平方根
	Math.sin()/cos()/tan()	//
	
28.Object	
	带_year可以表示只能通过方法访问的属性
	var person = {
		name: 'Nicolas',
		age: '29',
		job: 'SoftWare Engineer',
		
		sayName: function(){
			console.log(this.name);
		}
	}
	
	Object.defineProperty(person, "hobby", {
		writable: false,	// 是否能修改属性的值,设置成false就不能修改了,严格模式下赋值会报错 default: true
		value: '',			// 默认值
		configurable: false,// 是否能通过delete删除属性，能否重新定义属性 default: true
		enumerable: false	// 是否能通过for-in循环返回属性 default: true
	});//如果configurable false, 则不能使用些方法重复定义同一个对象的同一个属性，否则会报错
	
	访问器
	Object.defineProperty(person, "hobby", {	(这个问题似乎是因为writable的问题，好像它的默认是false, 通过defineProperty指定的，它的默认就是false。通过初始化指定的默认是true)
		configurable: false,	//是否能通过delete删除属性，能否重新定义属性 default: true
		enumerable: false, 		//能否通过for-in循环返回属性， default: true
		set: function(newValue){	//没有制定尝试写入就会报错
			this._hobby = newValue;
		},
		get: function(){			//没有指定就是undefined，严格模式下会报错
			return this._hobby
		}
	}
	
	定义多个属性
	Object.defineProperties(person, {
		_hobby:{
			value: "game"
		},
		hobby:{
			get: function(){
				return this._hobby;
			},
			set: function(newValue){
				this._hobby = newValue;
			}
		}
	})
	
	构造函数
		function Person(name, age, job){
			this.name = name;
			this.age = age;
			this.job = job;
			this.sayName = function(){
				console.log(this.name);
			}
		}
		var cyy = new Person("cyy", 21, "PG");
		console.log(cyy.name);
		任何函数只要通过new调用就会变成构造函数
		如果直接调用Person("cyy", 21, "PG");
		就是会添加到window
		也可以通过call/apply来调用
		var o = new Object();
		Person.call(o, "cyy", 21, "PG");
		
	工厂模式
		function createPerson(name, age, job){
			var o = new Object();
			o.name = name;
			o.age = age;
			o.job = job;
			o.sayName = function(){
				console.log(this.name);
			}
			return o;
		}